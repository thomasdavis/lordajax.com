# Weekly Activity: Optimizing Monorepo Development with Turborepo and pnpm

**text:** human
**code:** AI

This week provided an opportunity to step back and reflect on the development workflow and tooling choices that make modern monorepo development efficient and maintainable. While there wasn't significant GitHub activity to report, I want to share insights about the monorepo architecture that powers this project and why these tools matter.

## The Monorepo Challenge

Managing multiple related applications and packages in a single repository can quickly become complex. You need to handle:

- **Dependency management** across multiple packages
- **Build orchestration** to avoid rebuilding unchanged code
- **Script execution** that respects package dependencies
- **Code sharing** between applications without duplication
- **Development workflow** that remains fast as the repo grows

This is where a well-configured monorepo setup with Turborepo and pnpm becomes invaluable.

## Why Turborepo?

[Turborepo](https://turbo.build/repo) is a high-performance build system for JavaScript and TypeScript codebases. It solves several critical problems:

### 1. Intelligent Caching

Turborepo remembers what you've built and never does the same work twice. It uses content-aware hashing to determine if a package needs rebuilding:

```json
// AI
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "dev": {
      "cache": false
    }
  }
}
```

When you run `pnpm build`, Turborepo:
- Checks if the source files have changed
- Verifies if dependencies have been rebuilt
- Uses cached outputs if nothing changed
- Only rebuilds what's necessary

### 2. Dependency-Aware Task Execution

Turborepo understands your package dependencies and runs tasks in the correct order:

```bash
# AI
# Automatically builds dependencies first
pnpm turbo build

# Builds only packages that depend on 'ui'
pnpm turbo build --filter=...ui
```

The `^build` syntax in the pipeline configuration means "run build on all dependencies first." This ensures your shared packages are built before applications that depend on them.

### 3. Parallel Execution

Turborepo runs tasks in parallel whenever possible, dramatically reducing build times:

```bash
# AI
# Runs tests in parallel across all packages
pnpm turbo test

# Runs dev servers for multiple apps
pnpm turbo dev --parallel
```

## Why pnpm Workspaces?

[pnpm](https://pnpm.io/) is a fast, disk-efficient package manager that excels in monorepo environments:

### 1. Disk Space Efficiency

pnpm uses a content-addressable store for packages. Instead of duplicating `node_modules` in every package, it creates hard links to a global store:

```bash
# AI
# Traditional approach: ~500MB per package
# pnpm approach: ~500MB total, hard links everywhere
```

### 2. Strict Dependency Resolution

pnpm prevents packages from accessing undeclared dependencies, catching dependency issues early:

```json
// AI
// package.json in apps/homepage
{
  "dependencies": {
    "ui": "workspace:*"
  }
}
```

The `workspace:*` protocol tells pnpm to link to the local workspace package, ensuring you're always testing against your latest changes.

### 3. Workspace Filtering

pnpm provides powerful filtering for running commands in specific packages:

```bash
# AI
# Install dependencies only for homepage
pnpm --filter homepage install

# Run build for playground and its dependencies
pnpm --filter playground... build

# Run dev for all packages in the apps directory
pnpm --filter "./apps/*" dev
```

## Practical Workflow Examples

### Adding a New Shared Component

```bash
# AI
# 1. Add component to shared UI package
cd packages/ui
# Create new component...

# 2. Build the UI package
pnpm --filter ui build

# 3. Use in multiple apps
pnpm --filter homepage dev
pnpm --filter playground dev
```

Thanks to Turborepo's caching, if the UI package hasn't changed, subsequent builds are instant.

### Running Linting Across All Packages

```bash
# AI
# Runs lint in all packages, using cache when possible
pnpm turbo lint

# Only lint packages that changed since main branch
pnpm turbo lint --filter=[main]
```

### Optimizing CI/CD

Turborepo's remote caching can be configured for CI environments:

```yaml
# AI
# .github/workflows/ci.yml
- name: Build
  run: pnpm turbo build --cache-dir=.turbo
  env:
    TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
    TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
```

This allows your CI to share build artifacts across runs and even across different branches.

## Common Patterns

### Shared TypeScript Configuration

```json
// AI
// packages/tsconfig/base.json
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}

// apps/homepage/tsconfig.json
{
  "extends": "@repo/tsconfig/base.json",
  "compilerOptions": {
    "outDir": "./dist"
  }
}
```

### Shared ESLint Configuration

```javascript
// AI
// packages/eslint-config-custom/index.js
module.exports = {
  extends: ["next", "turbo", "prettier"],
  rules: {
    "@next/next/no-html-link-for-pages": "off",
  }
};

// apps/homepage/.eslintrc.js
module.exports = {
  extends: ["custom"]
};
```

## Performance Considerations

The combination of Turborepo and pnpm provides significant performance improvements:

1. **First install**: pnpm is typically 2-3x faster than npm
2. **Subsequent installs**: Nearly instant with pnpm's cache
3. **First build**: Turborepo builds in parallel
4. **Subsequent builds**: Instant with Turborepo's cache
5. **CI builds**: Shared remote cache eliminates redundant work

## Best Practices

### 1. Granular Package Structure

Keep packages focused and small. This maximizes caching benefits:

```
packages/
  ui/           # Shared components
  utils/        # Shared utilities
  config/       # Shared configuration
  types/        # Shared TypeScript types
```

### 2. Proper Task Dependencies

Define task dependencies correctly in `turbo.json`:

```json
// AI
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": ["coverage/**"]
    },
    "lint": {
      "outputs": []
    }
  }
}
```

### 3. Version Pinning

Use exact versions for external dependencies to ensure consistency:

```json
// AI
{
  "dependencies": {
    "react": "18.2.0",
    "ui": "workspace:*"
  }
}
```

## Troubleshooting Common Issues

### Cache Not Working

```bash
# AI
# Clear Turborepo cache
rm -rf .turbo

# Clear pnpm cache
pnpm store prune
```

### Dependency Resolution Issues

```bash
# AI
# Regenerate lockfile
rm pnpm-lock.yaml
pnpm install

# Verify workspace structure
pnpm list --depth=0
```

## Conclusion

A well-architected monorepo with Turborepo and pnpm provides a solid foundation for scaling JavaScript projects. The combination of intelligent caching, parallel execution, and efficient dependency management creates a development experience that remains fast regardless of repository size.

These tools don't just save timeâ€”they encourage better architecture by making it easy to share code and maintain consistency across packages. As your monorepo grows, these optimizations compound, keeping your development workflow smooth and efficient.

## Resources

- [Turborepo Documentation](https://turbo.build/repo/docs)
- [pnpm Documentation](https://pnpm.io/)
- [Turborepo Examples](https://github.com/vercel/turbo/tree/main/examples)
- [pnpm Workspaces Guide](https://pnpm.io/workspaces)
- [Monorepo Best Practices](https://monorepo.tools/)

Happy building!
